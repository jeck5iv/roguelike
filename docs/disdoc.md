
# Design Document — Roguelike Game System

## 1. Цель документа

Цель — зафиксировать технические решения, интерфейсы и модели данных для разработки консольной игры в жанре Roguelike. Документ охватывает архитектурные и проектные аспекты: от устройства карты и команд до боевой системы, поведения мобов и генерации побочных квестов.

---

## 2. Обоснование и требования

### 2.1 Общие принципы дизайна
- Чёткое разделение ответственности между модулями (SRP, SoC)
- Использование паттернов проектирования для обеспечения расширяемости
- Минимизация связности между компонентами
- Простота добавления новых сущностей, эффектов, квестов, стратегий

### 2.2 Функциональные требования
- Персонаж управляется с клавиатуры
- Карта может быть загружена или сгенерирована
- Поддержка предметов, инвентаря, экипировки
- Боевая система с мобами и уровнями
- Поведение мобов зависит от стратегии и состояния
- Генерация сайд-квестов
- Консольная визуализация игрового состояния

---

## 3. Ключевые подсистемы и их проект

### 3.1 Командная система (Command Pattern)

Все действия игрока реализуются как классы команд:

```python
class ICommand:
    def execute(self): ...

class MoveCommand(ICommand):
    def execute(self): ...

class AttackCommand(ICommand):
    def execute(self): ...
```

Преимущества:
- Разделение интерфейса и логики
- Возможность отката, записи истории
- Упрощение тестирования

---

### 3.2 Карта и генерация (Builder + Data-driven Map)

**Карта** — 2D-массив `Tile`, каждый `Tile` содержит:
- `passable: bool`
- `occupant: Optional[Entity]`
- `item: Optional[Item]`

```python
class MapBuilder:
    def from_file(path): ...
    def with_size(w, h): ...
    def with_mob_factory(factory): ...
    def build(): -> GameMap
```

Поддержка:
- Загрузки карт из файлов
- Генерации случайных карт
- Подключения фабрик мобов/предметов

---

### 3.3 Сущности и боевая система

**Entity** — базовый класс для всех существ.

```python
class Entity:
    health, attack, defense, position, inventory

class Player(Entity):
    level, experience

class Mob(Entity):
    strategy: IMobStrategy
    state: IMobState
```

**Бой:**
```python
class CombatSystem:
    def resolve(attacker, defender):
        damage = max(0, attack - defense)
        apply damage, check for death
```

---

### 3.4 Инвентарь и предметы (Decorator Pattern)

**Inventory**:
```python
class Inventory:
    items: List[Item]
    equipped: Dict[str, Item]

    def equip(item): ...
    def unequip(slot): ...
```

**Item**:
```python
class Item:
    name, type, modifiers
    def apply_effect(entity): ...
```

Эффекты экипировки — через модификаторы характеристик.

---

### 3.5 Поведение мобов (Strategy + State)

**Поведение = стратегия + состояние.**

```python
interface IMobStrategy:
    def decide_move(self, mob, world): -> Direction

interface IMobState:
    def modify_strategy(self, base: IMobStrategy) -> IMobStrategy
```

Примеры:
- Агрессивный моб: идёт к игроку
- Трусливый моб: уходит от игрока
- Паника: если HP < порога, стратегия меняется

---

### 3.6 Генерация квестов (Template + Random Fill)

```python
class Quest:
    description, goal, reward, status

class QuestGenerator:
    def generate(): -> Quest
```

Поддержка:
- Статических шаблонов
- Случайного выбора целей, мест, наград

---

### 3.7 Визуализация (Renderer)

```python
class Renderer:
    def render_map(game_map): ...
    def render_status(player): ...
    def render_log(messages): ...
```

Варианты реализации:
- `curses` (Linux/macOS)
- `windows-curses` или ANSI
- абстрагировать интерфейс под `IRenderer`

---

## 4. Интерфейсы и контракты

### Карта

```python
class GameMap:
    def get_tile(x, y): -> Tile
    def move_entity(entity, pos): ...
```

### Состояние сущностей

```python
class Entity:
    def take_damage(amount): ...
    def is_dead(): -> bool
```

### Команды

```python
class ICommand:
    def execute(): ...
```

---

## 5. Расширение и масштабирование

| Требование                  | Механизм реализации                        |
|----------------------------|---------------------------------------------|
| Новые мобы                 | Добавить стратегии и состояния              |
| Новые типы квестов         | Расширить генератор квестов                 |
| Новые предметы/эффекты     | Добавить в JSON + декоратор/модификатор     |
| Уровни/комнаты             | Добавить шаблоны в MapBuilder               |
| Сохранение/загрузка        | Сериализация GameState                      |
| Магия, дальние атаки       | Новые команды и расширение CombatSystem     |

---

## 6. Тестирование

| Компонент        | Тесты                             |
|------------------|------------------------------------|
| Inventory        | Проверка добавления, экипировки    |
| CombatSystem     | Расчёт урона, смерть, XP           |
| Strategy/State   | Переключение поведения мобов       |
| Commands         | Move/Attack работают корректно     |
| MapGenerator     | Карта связна, объекты размещены    |
| QuestSystem      | Генерация и завершение квестов     |

---

## 7. Trade-offs и альтернативы

| Решение                             | Альтернатива                   | Обоснование                          |
|-------------------------------------|---------------------------------|--------------------------------------|
| Командный ввод                      | Ифы в GameEngine                | Расширяемость, история               |
| Стратегии мобов через классы        | FSM внутри Mob                  | Простота тестирования и замены       |
| Хранение в JSON                     | YAML, SQLite                    | Простота + читабельность             |
| Рендер через curses                 | Rich, pygame                    | Минимум зависимостей                 |

---

## 8. План реализации

1. Подсистема карты и сущностей
2. Ввод и базовые команды
3. Боевая система
4. Мобы и поведение
5. Инвентарь и предметы
6. Квесты и генератор
7. Отрисовка и лог
8. Тесты + CI

---

## 9. Заключение

Данный дизайн-документ фиксирует единый подход к реализации всей системы Roguelike. Он учитывает текущее ТЗ и предполагаемое расширение проекта в рамках следующих итераций. Основной приоритет — чистая архитектура, модульность и простота поддержки.
